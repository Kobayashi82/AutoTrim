#define ENA 8
#define DIR 9
#define PUL 10

// Estados del motor
enum EstadoMotor {
  PARADO,
  MOVIENDO_PASOS,
  MOVIENDO_CONTINUO
};

// Variables de control
EstadoMotor estado = PARADO;
bool direccion = LOW;
int pasosRestantes = 0;
unsigned long ultimoPulso = 0;
bool estadoPulso = LOW;
int stepDelay = 150; // microsegundos

void setup() {
  pinMode(ENA, OUTPUT);
  pinMode(DIR, OUTPUT);
  pinMode(PUL, OUTPUT);
  
  digitalWrite(ENA, HIGH);  // Motor deshabilitado inicialmente
  digitalWrite(DIR, LOW);
  digitalWrite(PUL, LOW);
  
  Serial.begin(9600);
  Serial.println("Sistema listo (no bloqueante)");
}

void loop() {
  // 1. Procesar comandos del Serial (no bloqueante)
  procesarComandos();
  
  // 2. Generar pulsos si hay movimiento pendiente
  generarPulsos();
}

void procesarComandos() {
  if (Serial.available() > 0) {
    String comando = Serial.readStringUntil('\n');
    comando.trim();
    
    if (comando == "S") {
      // Stop - cancelar movimiento
      detenerMotor();
      Serial.println("Stop");
      
    } else if (comando == "H") {
      // Movimiento continuo horario
      iniciarMovimientoContinuo(LOW);
      Serial.println("Horario continuo");
      
    } else if (comando == "A") {
      // Movimiento continuo antihorario
      iniciarMovimientoContinuo(HIGH);
      Serial.println("Antihorario continuo");
      
    } else if (comando.startsWith("MH:")) {
      // Mover N pasos horario
      int pasos = comando.substring(3).toInt();
      iniciarMovimientoPasos(LOW, pasos);
      Serial.print("Comando: ");
      Serial.print(pasos);
      Serial.println(" pasos horario");
      
    } else if (comando.startsWith("MA:")) {
      // Mover N pasos antihorario
      int pasos = comando.substring(3).toInt();
      iniciarMovimientoPasos(HIGH, pasos);
      Serial.print("Comando: ");
      Serial.print(pasos);
      Serial.println(" pasos antihorario");
      
    } else if (comando.startsWith("SPEED:")) {
      // Cambiar velocidad
      int newSpeed = comando.substring(6).toInt();
      if (newSpeed >= 50 && newSpeed <= 5000) {
        stepDelay = newSpeed;
        Serial.print("Velocidad: ");
        Serial.println(stepDelay);
      }
    }
  }
}

void generarPulsos() {
  // Si el motor está parado, no hacer nada
  if (estado == PARADO) {
    return;
  }
  
  // Verificar si pasó suficiente tiempo desde el último pulso
  unsigned long tiempoActual = micros();
  if (tiempoActual - ultimoPulso >= stepDelay) {
    ultimoPulso = tiempoActual;
    
    // Alternar estado del pulso
    estadoPulso = !estadoPulso;
    digitalWrite(PUL, estadoPulso);
    
    // Si completamos un pulso (LOW después de HIGH)
    if (!estadoPulso && estado == MOVIENDO_PASOS) {
      pasosRestantes--;
      
      // Si terminamos todos los pasos
      if (pasosRestantes <= 0) {
        detenerMotor();
        Serial.println("Movimiento completado");
      }
    }
  }
}

void iniciarMovimientoPasos(bool dir, int pasos) {
  // Habilitar motor si estaba deshabilitado
  if (estado == PARADO) {
    digitalWrite(ENA, LOW);
  }
  
  // Configurar nueva dirección y pasos
  direccion = dir;
  digitalWrite(DIR, direccion);
  
  // AQUÍ ESTÁ LA CLAVE: El comando nuevo reemplaza al anterior
  pasosRestantes = pasos;
  estado = MOVIENDO_PASOS;
  
  // Resetear timing para empezar inmediatamente
  ultimoPulso = micros();
  estadoPulso = LOW;
}

void iniciarMovimientoContinuo(bool dir) {
  // Habilitar motor si estaba deshabilitado
  if (estado == PARADO) {
    digitalWrite(ENA, LOW);
  }
  
  direccion = dir;
  digitalWrite(DIR, direccion);
  
  estado = MOVIENDO_CONTINUO;
  ultimoPulso = micros();
  estadoPulso = LOW;
}

void detenerMotor() {
  estado = PARADO;
  pasosRestantes = 0;
  digitalWrite(PUL, LOW);
  digitalWrite(ENA, HIGH);  // Deshabilitar motor para ahorrar energía
}